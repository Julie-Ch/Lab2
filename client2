#! /usr/bin/env python3
import os, sys, struct, socket, threading, subprocess, time, signal, logging, argparse, concurrent.futures

Description ="""Client2 che riceve n file di testo da riga di comando e 
                per ogni file di testo crea un thread e manda 
                tutte le linee del file attraverso una connessione di tipo B"""

HOST = "127.0.0.1"  # The server's hostname or IP address
PORT = 59364    
MAX = 2048

def main(file):
  # inizializzazione socket client 
  with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    #connessione ad Host via Port 
    s.connect((HOST, PORT))
    print("Io", s.getsockname(), "sono connesso a", s.getpeername())
    #invio del carattere per il tipo di connessione
    s.sendall(struct.pack("<c",b'B'))
    with open(file, mode="r") as f:
      for item in f:
        # legge il byte inutile
        data = recv_all(s,1)
        if len(item) > MAX:
          print("Sequenza troppo lunga")
          break
        print("l:",len(item))
        #invio la lunghezza e la stringa
        s.sendall(struct.pack("<h",len(item)))
        s.send(item.encode())
      #ricevo byte inutile
      data = recv_all(s,1)
      #ed invio uno 0 per terminare
      s.sendall(struct.pack("<i",0))
      print(s.getsockname(), "finito")

#funzione recv_all come da lezione
def recv_all(conn,n):
  chunks = b''
  bytes_recd = 0
  while bytes_recd < n:
    chunk = conn.recv(min(n - bytes_recd, 1024))
    if len(chunk) == 0:
      raise RuntimeError("socket connection broken")
    chunks += chunk
    bytes_recd = bytes_recd + len(chunk)
  return chunks


if __name__ == '__main__':
  with concurrent.futures.ThreadPoolExecutor(max_workers=len(sys.argv)-1) as executor:
    for i in range(1, len(sys.argv)):
      executor.submit(main,sys.argv[i])
